{
    "collab_server" : "",
    "contents" : "# Define fcsFrame functions----------------\n\n#' label each clusters as \"+\" or \"-\" or neutral for each marker\n#'\n#' A function that label each cluster as \"+\" or \"-\" or neutral for each marker\n#' @param fcsFrame A flowFrame object.\n#' @param clusterList a list, each element should be a vector containing the IDs of all cells that are belong to a cluster\n#' @param excludeClusterParameters A vector specifiying the name of markers not to be used for labeling.\n#' @param minPercent a number between 0 and 0.5. Used to specify the minimum percent of cells in positive and negative region after bisection. Keep it small to avoid bisecting uni-mode distributions.\n#' @param labelQuantile a number between 0 and 0.5. Used to specify the minimum percent of a cluster required to be larger or smaller than the cutoff value for labeling.\n#' @return Returns a list with two components: 1) clusterLabel, contains a vector of lables, each correspond to a cluster in clusterList. 2) cutoff, contains a vector of cutoff values used to bisect each marker.\n#' @export\nlabelCluster= function(fcsFrame,\n                       clusterList,\n                       excludeClusterParameters=c(\"TIME\"),\n                       minPercent=0.05,\n                       labelQuantile=0.95,\n                       cutoff=NULL){\n\n  #prepare exclude parameters\n  excludeClusterParameters=toupper(excludeClusterParameters)\n  # get marker names\n  antibodies=markerFinder(fcsFrame)\n\n  # Get expression matrix\n  expr=flowCore::exprs(fcsFrame);\n  colnames(expr)=antibodies\n\n  # subset on columns\n  w = (!antibodies%in%excludeClusterParameters) #& (!channels%in%excludeClusterParameters)\n  antibodies=antibodies[w]\n  expr=expr[,w,drop=F]\n\n  #find cutoff of each parameter\n  if(is.null(cutoff)){\n    cutoff=apply(X=expr,MARGIN=2,FUN=findCutoff)\n  }\n\n  #label each cluster\n  CL_label=rep(NA,length(clusterList))\n  no_label=sapply(1:length(antibodies),function(i){\n    x1=quantile(expr[,i],minPercent)\n    x2= quantile(expr[,i],(1-minPercent))\n    if(cutoff[i]<x1|cutoff[i]>x2){return(T)}else{return(F)}\n  })\n  for(i in 1:length(clusterList)){\n    l=c()\n    for(j in 1:length(antibodies)){\n      if(no_label[j]==T){next}\n      x=expr[clusterList[[i]],j]\n      if(quantile(x,labelQuantile)<cutoff[j]){\n        l=c(l,paste0(antibodies[j],\"-\"))\n      }else if(quantile(x,(1-labelQuantile))>cutoff[j]){\n        l=c(l,paste0(antibodies[j],\"+\"))\n      }\n    }\n    l=paste(l,collapse=\"|\")\n    CL_label[i]=l\n  }\n\n  # merge clusters with the same labels\n  CL_label=unique(CL_label)\n\n  # find cluster with 1 sign difference, merge to create new cluster\n  while(length(CL_label)>1){\n    label_pair=combn(CL_label,2)\n    new_label=apply(label_pair,2,labelCombiner)\n    w=which(new_label%in%CL_label)\n    new_label[w]=NA\n    if(sum(!is.na(new_label))==0){break}\n    w=which(!is.na(new_label))\n    CL_label=c(CL_label,new_label[w])\n  }\n\n  CL_label=labelUnifier(CL_label)\n  CL_label=unique(CL_label)\n  Result=list(\"clusterLabel\"=CL_label,\"cutoff\"=cutoff)\n  return(Result)\n}\n\n#' search for clusters using pre-defined labels\n#'\n#' A function that search for clusters using pre-defined labels\n#' @param fcsFrame A flowFrame object.\n#' @param clusterLabel a vector of labels, such as \"CD3+|CD4+|CD8-\"\n#' @param cutoff a vector of cutoff values to bisect the distribution of each\n#'   marker. The names of the vector should be the same as the marker names. If\n#'   NULL, the cutoff value will be determined automatically.\n#' @param rmNULL True or False. Used to specifiy if a cluster with 0 cells\n#'   should be returned or not.\n#' @return Returns a list with two components: 1) clusterList, contains a list.\n#'   Each element of the list is a vector containing the ID of all cells in a\n#'   cluster. The names corresponds to the labels specified in clusterLabel. 2)\n#'   cutoff, contains a vector of cutoff values used to bisect each marker.\n#' @export\nsearchCluster=function(fcsFrame,\n                       clusterLabel,\n                       cutoff=NULL,\n                       rmNull=T,\n                       preGate=NULL){\n\n  #prepare exclude parameters\n  clusterLabel=toupper(clusterLabel)\n  antibodies=markerFinder(fcsFrame)\n\n  # Get expression matrix\n  expr=flowCore::exprs(fcsFrame);\n  colnames(expr)=antibodies\n\n\n  # pre-gating\n  if(!is.null(preGate)){\n    preGate=toupper(preGate)\n    pre_vec = strsplit(preGate,split=\"&|\\\\|\")[[1]]\n    pre_marker = gsub(\"\\\\+$|-$|\\\\^NE$|\\\\^LO$|\\\\^HI$\",\"\",pre_vec )\n\n      cutoff0=apply(X=expr[,pre_marker,drop=F],MARGIN=2,FUN=findCutoff)\n\n    P1=sapply(pre_vec,function(x){\n      m=gsub(\"\\\\+$|-$|\\\\^NE$|\\\\^LO$|\\\\^HI$\",\"\",x)\n      if(grepl(\"\\\\+$\",x)){w=which(expr[,m]>cutoff0[m])}\n      if(grepl(\"-$\",x)){w=which(expr[,m]<cutoff0[m])}\n      if(grepl(\"\\\\^NE$\",x)){w=which(expr[,m]<triS[2,m])}\n      if(grepl(\"\\\\^LO$\",x)){w=which(expr[,m]<triS[1,m])&expr[,m]>triS[2,m]}\n      if(grepl(\"\\\\^HI$\",x)){w=which(expr[,m]>triS[1,m])}\n      return(w)\n    })\n    if(length(pre_vec)>1){P1=Reduce(intersect,P1)}\n  }\n\n  # subset expr\n  AB=unlist(strsplit(clusterLabel,split=\"&|\\\\|\"))\n  AB=sapply(AB,function(x){gsub(\"\\\\+$|-$|\\\\^NE$|\\\\^LO$|\\\\^HI$\",\"\",x)})\n  w=which(antibodies%in%AB)\n  expr=expr[,w,drop=F]\n\n  #find labels whose markers are included in the study\n  CL_label=clusterLabel\n  CL_label2=strsplit(clusterLabel,split=\"&|\\\\|\")\n  in_study=sapply(CL_label2,function(x){\n    Ab_in_label=gsub(\"\\\\+$|-$|\\\\^NE$|\\\\^LO$|\\\\^HI$\",\"\",x)\n    if(length(setdiff(Ab_in_label,antibodies))>0){return(F)}else{return(T)}\n  })\n  CL_label=CL_label[in_study]\n  CL_label2=CL_label2[in_study]\n  if(length(CL_label)<1){return(list())}\n\n  #find cutoff of each parameter\n  if(is.null(cutoff)){\n    cutoff=apply(X=expr[P1,],MARGIN=2,FUN=findCutoff)\n  }\n\n  #find each cluster\n  CL=list()\n  for(i in 1:length(CL_label2)){\n    rows=sapply(CL_label2[[i]],function(x){\n      m=gsub(\"\\\\+$|-$|\\\\^NE$|\\\\^LO$|\\\\^HI$\",\"\",x)\n      if(grepl(\"\\\\+$\",x)){w=which(expr[,m]>cutoff[m])}\n      if(grepl(\"-$\",x)){w=which(expr[,m]<cutoff[m])}\n      if(grepl(\"\\\\^NE$\",x)){w=which(expr[,m]<triS[2,m])}\n      if(grepl(\"\\\\^LO$\",x)){w=which(expr[,m]<triS[1,m])&expr[,m]>triS[2,m]}\n      if(grepl(\"\\\\^HI$\",x)){w=which(expr[,m]>triS[1,m])}\n      return(w)\n    })\n    if(length(CL_label2[[i]])>1){rows=Reduce(intersect,rows)}\n    CL[[i]]=rows\n  }\n  if(rmNull==T){\n    CL_count=sapply(CL,length)\n    CL=CL[CL_count>1]\n    CL_label=CL_label[CL_count>1]\n  }\n\n  if(length(CL)<1){return(list())}\n  CL=lapply(CL,intersect,y=P1)\n\n  names(CL)=CL_label\n  Result=list(\"clusterList\"=CL,\"cutoff\"=cutoff)\n  return(Result)\n}\n\n#' preprocess fcs files from a single experiment\n#'\n#' A function that preprocess fcs files from a single experiment.\n#' @param fcsFiles A vector specifying the location of all fcs files.\n#' @param assay Either \"FCM\" or \"CyTOF\" to indicate the type of cytometry data.\n#' @param b a positive number used to specify the arcsinh transformtion. f(x) = asinh (b*x) where x is the original value and f(x) is the value after transformation. The suggested value is 1/150 for flow cytometry (FCM) data and 1/8 for CyTOF data.\n#' @param fileSampleSize An integer specifying the number of events sampled from each fcs file. If NULL, all the events will be pre-processed and wrote out to the new fcs files.\n#' @param excludeTransformParameters A vector specifiying the name of parameters not to be transformed (left at linear scale).\n#' @return Returns a flowFrame object containing the preprocessed cytometry data. Cells from different fcs files are combined into one flow frame. A new paramter, sample_id, is introduced to indicate the origin of each cell.\n#' @export\npreprocessing=function(fcsFiles,\n                       assay=c(\"FCM\", \"CyTOF\"),\n                       b=1/200,\n                       fileSampleSize=5000,\n                       excludeTransformParameters=c(\"FSC-A\",\"FSC-W\",\"FSC-H\",\"Time\",\"Cell_length\")){\n\n  fcs_param=NULL\n  fcs_names= gsub(\".*/\",\"\",fcsFiles)\n  excludeTransformParameters=paste(excludeTransformParameters,collapse=\"|\")\n\n\n  cat(\"Preprocessing \\n\")\n\n  # 1) identify sample :\n  fcsFiles=as.character(fcsFiles)\n\n  # 2) read the fcs files\n  fcs = flowCore::read.flowSet(fcsFiles,transformation=\"linearize\",alter.names=FALSE,truncate_max_range=F)\n  if(!is.null(fileSampleSize)){\n    fcs = flowCore::fsApply(fcs, function(f){\n      L=nrow(f@exprs)\n      if(L>fileSampleSize){\n        f@exprs=f@exprs[sample(1:L,fileSampleSize),]\n      }\n      return(f)\n    })\n  }\n\n  # 3) compensation and transformation\n  if (assay == \"FCM\") {\n    # retreiving fluorescent biomarkers\n    w=which(!grepl(excludeTransformParameters,flowCore::colnames(fcs),ignore.case = T))\n    biomarker_vector = flowCore::colnames(fcs)[w]\n    # identify the fcs file format\n    version = flowCore::fsApply(fcs, function(frame) {\n      return(flowCore::keyword(frame, \"FCSversion\")[[1]])\n    })\n    unique_version = as.numeric(unique(as.vector(version)))\n\n    # compensation, transformation\n    ## if the file version is 2.0, then code will log transform the data\n    if (unique_version == 2) {\n      trans = flowCore::logTransform()\n      translist = flowCore::transformList(biomarker_vector,trans)\n      fcs = flowCore::transform(fcs, translist)\n    } else if (unique_version == 3) {\n\n      ### function first checks if the spill matrix in the flowframe is an actual spill matrix or an identity matrix\n      if (is.null(flowCore::keyword(fcs[[1]], \"SPILL\")[[1]]) == FALSE) {\n        check = flowCore::fsApply(fcs, function(x) {\n          result = isSymmetric(flowCore::keyword(x, \"SPILL\")[[1]])\n        })\n        ### if all flowframes have spill matrices then my function\n        ### will apply them to each flowframe in the flowset for compensation\n        if (unique(check)[[1]] == FALSE) {\n          fcs = flowCore::fsApply(fcs, function(x) {\n            new_frame = flowCore::compensate(x, flowCore::keyword(x, \"SPILL\")[[1]])\n            return(new_frame)\n          })\n        }\n      }\n\n      trans = flowCore::arcsinhTransform(transformationId=\"defaultArcsinhTransform\",a=0,b=b,c=0)\n      translist = flowCore::transformList(biomarker_vector, trans)\n      fcs = flowCore::transform(fcs, translist)\n    }\n  } else if (assay == \"CyTOF\") {\n    w=which(!grepl(excludeTransformParameters,flowCore::colnames(fcs),ignore.case = T))\n    biomarker_vector = flowCore::colnames(fcs)[w]\n\n    trans = flowCore::arcsinhTransform(transformationId = \"defaultArcsinhTransform\", a = 0, b = b, c = 0)\n    translist = flowCore::transformList(biomarker_vector, trans)\n    fcs = flowCore::transform(fcs, translist)\n  }\n  fcs=set2Frame(fcs)\n  return(fcs)\n}\n\n#' derive summary statistics for clusters\n#'\n#' A function that derives summary statistics for clusters.\n#' @param fcsFrame A flow Frame object returned from preprocessing function. Must contain a parameter called \"sample_id\" that specifiy the origin of each cell using integer IDs.\n#' @param clusterList a list, each element should be a vector containing the IDs of all cells that are belong to a cluster\n#' @param fcsNames a vector of fcs file names. Each element corresponds to an interger ID in the \"sample_id\" parameter in fcsFrame.\n#' @return Returns a data frame, with rows correspond to each fcs file, columns correspond to markers or fractions.\n#' @export\nclusterStats=function(fcsFrame,clusterList,fcsNames){\n  antibodies=markerFinder(fcsFrame)\n  expr=flowCore::exprs(fcsFrame)\n  colnames(expr)=antibodies\n  CL=clusterList\n  CL_label=names(clusterList)\n  sample_name=fcsNames\n  expr_sample=expr[,\"SAMPLE_ID\"]\n  expr=expr[,colnames(expr)!=\"SAMPLE_ID\"]\n  antibodies=antibodies[antibodies!=\"SAMPLE_ID\"]\n  SP_stat=NULL\n  for(i in 1:length(CL)){\n    for(j in unique(expr_sample)){\n      fileSampleSize=sum(expr_sample==j)\n      w=intersect( which(expr_sample==j), CL[[i]] )\n      frac=length(w)/fileSampleSize\n      if(length(w)>1){M=apply(expr[w,],2,median)}\n      if(length(w)==1){M=expr[w,]}\n      if(length(w)==0){M=rep(NA,ncol(expr))}\n      t1=c(paste0(\"cluster\",i),CL_label[i],sample_name[j],M,frac)\n      SP_stat=rbind(SP_stat,t1)\n    }\n  }\n  colnames(SP_stat)=c(\"cluster_id\",\"label\",\"fcs_names\",antibodies,\"fraction\")\n  rownames(SP_stat)=NULL\n  SP_stat=data.frame(SP_stat,stringsAsFactors = F,check.names = F)\n  SP_stat[,1:3]=lapply(SP_stat[,1:3],as.character)\n  SP_stat[,-c(1:3)]=lapply(SP_stat[,-c(1:3)],as.numeric)\n\n  return(SP_stat)\n}\n\n#' draw density plot for each cluster.\n#'\n#' A function that draw density plot for each cluster.\n#' @param fcsFrame A flow Frame object returned from preprocessing function.\n#' @param clusterList a list, each element should be a vector containing the IDs of all cells that are belong to a cluster\n#' @param cutoff a vector of cutoff values to bisect the distribution of each\n#'   marker. The names of the vector should be the same as the marker names.\n#' @param markerToPlot a vector specifying markers included in the plot. If NULL, all markers will be plotted.\n#' @return NULL. The plot will show up automatically.\n#' @export\ndensityPlot=function(fcsFrame,clusterList,cutoff,markerToPlot=NULL){\n  CL_label=toupper(names(clusterList))\n  markerToPlot=toupper(markerToPlot)\n  antibodies=markerFinder(fcsFrame)\n  expr=flowCore::exprs(fcsFrame);\n  colnames(expr)=antibodies\n  if(length(markerToPlot)<1){markerToPlot=antibodies}\n  #antibodies=toupper(names(cutoff))\n  #expr=expr[,antibodies]\n  CL=clusterList\n  par( mfcol = c(length(CL), length(markerToPlot) ) )\n  for(i in 1:length(markerToPlot)){\n    x_all=expr[,markerToPlot[i]]\n    for(j in 1:length(CL)){\n      b=seq(min(x_all),max(x_all), ((max(x_all)-min(x_all))/100) )\n      hist(x_all,col=rgb(0, 0, 0, 0.2),xlab=markerToPlot[i],breaks=b,freq=T,border=F,main=paste0(markerToPlot[i],\" of cluster \",j,\" : \\n\", CL_label[j]))\n      hist(expr[CL[[j]],markerToPlot[i]],add=T,breaks=b,col=rgb(1, 0, 0, 0.5),freq=T,border=F)\n      if(markerToPlot[i]%in%names(cutoff)){abline(v=cutoff[markerToPlot[i]])}\n    }\n  }\n}\n\n\n# Define batch functions----------------\n\n#' preprocessing fcs files from different studies in batch.\n#'\n#' It transform and compensate for the raw fcs files and write out the processed data to a new set of fcs files.\n#' @param inputMeta A dataframe containing 2 columns: a column called \"fcs_files\" that contains the location (relative to the working directory) of each fcs file on the hard drive and a column called \"study_id\" that specify what study each fcs file belongs to.\n#' @param assay Either \"FCM\" or \"CyTOF\" to indicate the type of cytometry data.\n#' @param outpath a string indicating the directory the pre-processed fcs files will be wrote to.\n#' @param b a positive number used to specify the arcsinh transformtion. f(x) = asinh (b*x) where x is the original value and f(x) is the value after transformation. The suggested value is 1/150 for flow cytometry (FCM) data and 1/8 for CyTOF data.\n#' @param fileSampleSize An integer specifying the number of events sampled from each fcs file. If NULL, all the events will be pre-processed and wrote out to the new fcs files.\n#' @param excludeTransformParameters A vector specifiying the name of parameters not to be transformed (left at linear scale).\n#' @return Does not return anything. The output is wrote to the directory specified by the \"outpath\".\n#' @details The function takes a data frame which specify the location of the fcs files and the panels the fcs files belong to. It transform the cytometry data using the arcsinh transformtion. For flow cytometry data, it compensate the data using the compensation matrix supplied in the fcs file. the preprocessed fcs files and a table called \"processed_sample_summary.csv\" will be wrote out to outpath as well.\n#' @export\n\npreprocessing.batch = function(inputMeta,\n                               assay=c(\"FCM\", \"CyTOF\"),\n                               outpath,\n                               b=1/150,\n                               fileSampleSize=5000,\n                               excludeTransformParameters=c(\"FSC-A\",\"FSC-W\",\"FSC-H\",\"Time\",\"Cell_length\")){\n\n  fcs_param=NULL\n  fcs_names= gsub(\".*/\",\"\",inputMeta$fcs_files)\n  excludeTransformParameters=paste(excludeTransformParameters,collapse=\"|\")\n  dir.create(outpath,recursive=T)\n  if(length(b)==1){b=rep(b,nrow(inputMeta))}\n  if(length(assay)==1){assay=rep(assay,nrow(inputMeta))}\n  for(std in unique(inputMeta$study_id)){\n\n    cat(\"Study ID = \",std, \" \")\n\n    # 1) identify sample :\n    fcs_files=subset(inputMeta$fcs_files,inputMeta$study_id==std)\n    fcs=preprocessing(fcsFiles=fcs_files,\n                      assay=subset(assay,inputMeta$study_id==std)[1],\n                      b=subset(b,inputMeta$study_id==std)[1],\n                      fileSampleSize=fileSampleSize,\n                      excludeTransformParameters=excludeTransformParameters)\n\n    # 5) outputting resuts\n    flowCore::write.FCS(fcs,filename=paste0(outpath,'/',std,\".fcs\"))\n\n    antibodies=markerFinder(fcs)\n    antibodies=paste(antibodies,collapse=\"|\")\n    fcs_param=rbind(fcs_param,data.frame(\"fcs_files\"=fcs_files,\"study_id\"=std,\"antibodies\"=antibodies))\n  }\n  fcs_param=cbind(\"fcs_names\"=fcs_names,fcs_param)\n  write.csv(fcs_param,paste0(outpath,\"/processed_sample_summary.csv\"),row.names=F)\n  cat(\"Preprocess result stored in the folder:\",outpath, \"\\n\")\n}#end of function\n\n\n#' Cluster the preprocessed fcs files from different studies in batch\n#'\n#' A function that clusters the pre-processed fcs files from different studies in batch.\n#' @param preprocessOutputFolder Directory where the preprocessed results are stored. Should be the same with the outpath argument in preprocessing.batch function.\n#' @param excludeClusterParameters A vector specifiying the name of markers not to be used for clustering and labeling. Typical example includes: Time, cell_length.\n#' @param labelQuantile A number between 0 and 0.5. Used to specify the minimum percent of cells in a cluster required to be larger or smaller than the cutoff value for labeling.\n#' @param clusterFunction The name of unsuperviesed clustering function the user wish to use for clustering the cells. The default is \"flowSOM.MC\". The first argument of the function must take a flow frame, the second argument of the function must take a vector of excludeClusterParameters. The function must returns a list of clusters containing cell IDs. flowSOM.MC and flowHC are implemented in the package. For other methods, please make your own wrapper functions.\n#' @param minPercent a number between 0 and 0.5. Used to specify the minimum percent of cells in positive and negative region after bisection. Keep it small to avoid bisecting uni-mode distributions.\n#' @param ... pass arguments to labelCluster and clusterFunction\n#' @return a vector of labels identified in the cytometry data.\n#' @export\nautoCluster.batch= function(preprocessOutputFolder,\n                            excludeClusterParameters=c(\"TIME\"),\n                            labelQuantile=0.9,\n                            clusterFunction=flowSOM.MC,\n                            minPercent=0.05,...){\n  #read the output from preprocessing\n  inputMeta=read.csv(paste0(preprocessOutputFolder,'/processed_sample_summary.csv'),stringsAsFactors=F)\n  #create output foler\n\n  #prepare exclude parameters\n  excludeClusterParameters=toupper(excludeClusterParameters)\n  all_labels=NULL\n  for(std in unique(inputMeta$study_id)){\n    cat(\"Clustering , study ID = \",std, \"\\n\")\n\n    ##### 1) read sample files for each study############################################################\n    fcs_files=paste0(preprocessOutputFolder,\"/\",std,\".fcs\")\n    fcs=flowCore::read.FCS(fcs_files,truncate_max_range=F)\n\n    # make sure the fcs file antibody names are the same as the preprocessed output\n    antibodies=subset(inputMeta$antibodies,inputMeta$study_id==std)[1]\n    antibodies=strsplit(antibodies,\"\\\\|\")[[1]]\n\n    ##### 2) subset the cells in fcs ############################################################\n    # Get expression matrix\n    expr=flowCore::exprs(fcs);\n    colnames(expr)=antibodies\n\n    # subset on columns\n    w=!antibodies%in%excludeClusterParameters\n    antibodies=antibodies[w]\n    if(length(antibodies)<2){next}\n    expr=expr[,w,drop=F]\n    expr_scale=scale(expr,center=F,scale=T)\n    fcs=flowCore::flowFrame(expr_scale)\n\n    CL=clusterFunction(fcs,excludeClusterParameters,...)\n    CL_label=labelCluster(fcs,CL,excludeClusterParameters,\n                          labelQuantile=labelQuantile,\n                          minPercent=minPercent,...)\n    all_labels=union(all_labels,CL_label$clusterLabel)\n  }#end of each study\n  return(all_labels)\n}\n\n#' search for clusters using pre-defined labels in cytometry data from different studies in batch\n#'\n#' A function that search for clusters using pre-defined labels in cytometry data from different studies in batch.\n#' @param preprocessOutputFolder directory where the pre-processed results are stored.\n#' @param outpath a string indicating the directory the results should be write to.\n#' @param clusterLabel a vector containing labels, such as \"CD3+|CD4+|CD8-\"\n#' @param ifPlot True or False. Used to specifiy if a the density plot for each cluster should be plotted\n#' @return NULL\n#' @details The function write out the summary statistics for each cluster. A seperate directory will be created for each study.\n#' @export\nsearchCluster.batch=function(preprocessOutputFolder,\n                             outpath=\"search_output\",\n                             clusterLabel,\n                             ifPlot=T){\n\n  #read the output from preprocessing\n  inputMeta=read.csv(paste0(preprocessOutputFolder,'/processed_sample_summary.csv'),stringsAsFactors=F)\n  #create output foler\n  dir.create(file.path(outpath),recursive=T)\n\n  #prepare exclude parameters\n  clusterLabel=toupper(clusterLabel)\n  cluster_summary=NULL\n  for(std in unique(inputMeta$study_id)){\n    cat(\"Searching , study ID = \",std, \"\\n\")\n    dir.create(paste(outpath,std,sep=\"/\"))\n    ##### 1) read sample files for each study############################################################\n    fcs_files=paste0(preprocessOutputFolder,\"/\",std,\".fcs\")\n    fcs=flowCore::read.FCS(fcs_files,truncate_max_range=F)\n\n    # make sure the fcs file antibody names are the same as the preprocessed output\n    antibodies=subset(inputMeta$antibodies,inputMeta$study_id==std)[1]\n    antibodies=strsplit(antibodies,\"\\\\|\")[[1]]\n\n    ##### 2) subset the cells in fcs ############################################################\n    # Get expression matrix\n    expr=flowCore::exprs(fcs);\n    colnames(expr)=antibodies\n    fcs=flowCore::flowFrame(expr)\n\n    ##### 3) bisect each marker############################################################\n    sC=searchCluster(fcsFrame=fcs,clusterLabel=clusterLabel)\n    CL=sC$clusterList\n    CL_label=names(CL)\n    if(length(CL)<1){next}\n\n    CL_stats=clusterStats(fcs,CL,inputMeta$fcs_names[inputMeta$study_id==std])\n    CL_stats=cbind(\"study_id\"=std,\"fcs_files\"=inputMeta$fcs_files[inputMeta$study_id==std],CL_stats)\n    write.csv(CL_stats,paste(outpath,std,\"cluster_stats_in_each_sample.csv\",sep=\"/\"),row.names=F)\n\n    ##### 6) plot the density plot############################\n    if(ifPlot==T){\n      filename=paste(outpath,std,\"density_plot.pdf\",sep=\"/\")\n      height=3*length(CL);width=3*length(antibodies)\n      pdf(filename,width=width,height=height)\n      densityPlot(fcs,CL,cutoff=sC$cutoff)\n      dev.off()\n    }\n  }#end of each study\n}\n# Define supporting functions---------\n\n#' organize fcs files in a study from ImmPort into panels\n#'\n#' A function that organizes fcs files in a study from ImmPort into panels.\n#' @param metaData a data frame. Must contain a column listing the names of fcs files included in the study.\n#' @param studyFolder Path of directory containing all the files of a study from ImmPort.\n#' @param fcsCol a string specifiying the name of the column in metaData that lists fcs files included in the study.\n#' @param assay Either \"FCM\" or \"CyTOF\" to indicate the type of cytometry data.\n#' @return A dataframe containing 2 columns: a column called \"fcs_files\" that contains the location (relative to the working directory) of each fcs file on the hard drive and a column called \"study_id\" that specify what study each fcs file belongs to.\n#' @export\nfcsInfoParser =function(metaData,\n                        studyFolder,\n                        fcsCol=\"ZBXFN\",\n                        assay=c(\"FCM\", \"CyTOF\")){\n  cat(\"Parsing the meta-data from ImmPort\\n\")\n  metaData=unique(metaData[,fcsCol,drop=FALSE])\n\n  if(assay==\"FCM\"){\n    fcs_files=paste(studyFolder,\"ResultFiles/Flow_cytometry_result\",metaData[,fcsCol],sep=\"/\")\n  }else{\n    fcs_files=paste(studyFolder,\"ResultFiles/CyTOF_result\",metaData[,fcsCol],sep=\"/\")\n  }\n  fsc_markers=sapply(fcs_files,function(x){\n    tryCatch({\n      fcs=flowCore::read.FCS(x,truncate_max_range=F)\n      panel=paste(flowCore::pData(flowCore::parameters(fcs))$name,\n                  flowCore::pData(flowCore::parameters(fcs))$desc, sep=\"-\")\n      return(paste(panel,collapse=\"|\"))\n    },error=function(e){return(\"DoesNotExist\")})\n  })\n  study=sapply(fsc_markers,function(x){\n    if(x==\"DoesNotExist\" ){return(\"DoesNotExist\")}\n    w=which(unique(fsc_markers)==x);\n    w=paste0(gsub(\"/\",\"_\",studyFolder),\"_\",assay,\"-\",w)\n    return(w)\n  })\n  names(study)=NULL\n  inputMeta=data.frame(\"fcs_files\"=fcs_files,\"study_id\"=study)\n\n  inputMeta=subset(inputMeta,!grepl(\"DoesNotExist\",inputMeta$study_id))\n  inputMeta=unique(inputMeta)\n  inputMeta$fcs_files=as.character(inputMeta$fcs_files)\n  return(inputMeta)\n}\n\n#' collect and combine data from multiple csv files of the same format\n#'\n#' A function that collect and combine data from multiple csv files of the same format.\n#' @param files a vector containing the paths of csv files to be combined.\n#' @param longform True or False. Used to specify if the table in each csv file should be converted into long form before combining.\n#' @return A dataframe containing conbined information from multiple csv files.\n#' @export\ncollectData=function(files,longform=T){\n  all_data=NULL\n  nms=NULL\n  for(fn in files){\n    #read output data from \"autoCluster\" function\n    cluster_stat=read.csv(fn,stringsAsFactors=F,check.names=F)\n    if(is.null(nms)){nms=colnames(cluster_stat)}\n    w=which(nms==\"fcs_names\")+1\n    if(longform==T){\n      cluster_stat=tidyr::gather(cluster_stat,parameter_name, value ,w:ncol(cluster_stat))\n    }else(colnames(cluster_stat)=nms)\n    all_data=rbind(all_data,cluster_stat)\n  }\n  return(all_data)\n}\n\n#' collect sample information for fcs files in  a study from ImmPort.\n#'\n#' A function that collect sample information for fcs files in  a study from ImmPort..\n#' @param metaData a data frame. Must contain a column listing the names of fcs files included in the study.\n#' @param studyFolder Path of directory containing all the files of a study from ImmPort.\n#' @param fcsCol a string specifiying the name of the column in metaData that lists fcs files included in the study.\n#' @param assay Either \"FCM\" or \"CyTOF\" to indicate the type of cytometry data.\n#' @param attrCol a vector of column names. Used to specify the information about each cytometry the user wish to include in the analysis.\n#' @return A dataframe containing sample information.\n#' @export\nsampleInfoParser =function(metaData=selected_data,\n                           studyFolder,\n                           fcsCol=\"ZBXFN\",\n                           assay=\"FCM\",\n                           attrCol){\n  if(assay==\"FCM\"){\n    fcs_files=paste(studyFolder,\"ResultFiles/Flow_cytometry_result\",metaData[,fcsCol],sep=\"/\")\n  }else{\n    fcs_files=paste(studyFolder,\"ResultFiles/CyTOF_result\",metaData[,fcsCol],sep=\"/\")\n  }\n  inputMeta=data.frame(\"fcs_files\"=fcs_files)\n  inputMeta=cbind(inputMeta,metaData[,attrCol])\n  inputMeta=unique(inputMeta)\n  inputMeta$fcs_files=as.character(inputMeta$fcs_files)\n  return(inputMeta)\n}\n\n\n#' summarize markers in panels.\n#'\n#' A function that summarize markers in panels.\n#' @param panelInfo a data frame returned by collectData function. It should contain all the information outputted by the preprocessing.batch function.\n#' @param folder the directory where the output should be written\n#' @param cluster True or False. Used to indicate if the markers and panels should be clustered in the plot.\n#' @param plotImage True or False. Used to indicate if a plot summarizing markers in  panels should be produced.\n#' @param width Used to specify the width of the plot\n#' @param height Used to specify the height of the plot\n#' @return A dataframe describing what markers are in each panel.\n#' @export\npanelSummary=function(panelInfo,folder,cluster=T,plotImage=T,width=20,height=20){\n  panelInfo=unique(panelInfo[,c(\"study_id\",\"antibodies\")])\n  ab_list=NULL\n  for(i in 1:nrow(panelInfo)){\n    t1=strsplit(panelInfo$antibodies[i],split=\"\\\\|\")[[1]]\n    t1=t1[t1!=\"NA\"&is.na(t1)==F]\n    if(length(t1)>0){\n      ab_list=rbind(ab_list, data.frame(\"study_id\"=panelInfo$study_id[i],\"antibodies\"=t1,\"value\"=1))\n    }\n  }\n  ab_list=unique(ab_list)\n  #ab_list=unique(ab_list)\n  ab_table=tidyr::spread(ab_list,key=antibodies,value=value,fill=0)\n  rownames(ab_table)=ab_table$study_id;ab_table=ab_table[,-1]\n  ab_table=t(data.matrix(ab_table))\n  if(cluster==T){\n    d=as.dist(1-cor(ab_table))\n    c1=hclust(d)$order\n    d=as.dist(1-cor(t(ab_table)))\n    r1=hclust(d)$order\n    ab_table=ab_table[r1,c1]\n  }\n  write.csv(ab_table,paste0(folder,\"/panel_summary.csv\"))\n\n  if(plotImage==T){\n    pdf(paste0(folder,\"/panel_summary.pdf\"),width=width,height=height)\n    op <- par(mar = c(30,30,30,10))\n    image(z = ab_table, col = c(\"white\",\"red\"), axes = F)\n    t1=1/(nrow(ab_table)-1)\n    axis(side = 3, labels = rownames(ab_table),las=2,cex.axis=3,\n         at = seq(0, 1,by = t1))\n    t1=1/(ncol(ab_table)-1)\n    axis(side = 2, labels = colnames(ab_table),las=2,cex.axis=3,\n         at = seq(0, 1,by = t1))\n    box()\n    par(op)\n    dev.off()\n  }\n  return(ab_table)\n}\n\n\n\n\n#' Used to update marker names\n#'\n#' A function that update marker names in the files output by the preprocessing.batch function.\n#' @param oldNames a vector of marker names you wish to change\n#' @param newNames a vector of marker names you wish each oldNames to be changed to.\n#' @param files a list of \"processed_sample_summary.csv\" files in which the name change will ocurre.\n#' @return Null\n#' @export\nnameUpdator=function(oldNames,newNames,files){\n  oldNames=as.vector(oldNames)\n  newNames=as.vector(newNames)\n  for(fn in files){\n    TB=read.csv(fn,stringsAsFactors=F,check.names=F)\n    for(i in 1:length(newNames)){\n      TB$antibodies=sapply(TB$antibodies,function(x){\n        gsub(oldNames[i],newNames[i],x,fixed=T)\n      })\n    }\n    write.csv(TB,fn,row.names=F)\n  }\n}\n\n#' combine cells in a flow set into a flow frame.\n#'\n#' A function that combine cells in a flow set into a flow frame.\n#' @param flowSet a flow set object\n#' @return Returns a flowFrame object. All cells from flow set are combined into one flow frame. A new paramter, sample_id, is introduced to indicate the origin of each cell.\n#' @export\nset2Frame=function(flowSet){\n  expr=flowCore::fsApply(flowSet,function(x){\n    v=flowCore::exprs(x);\n    return(v)\n  })\n  eventN=flowCore::fsApply(flowSet,function(x){\n    v=flowCore::exprs(x);\n    n=nrow(v)\n    return(n)\n  })\n  Label=flowCore::fsApply(flowSet,function(x){\n    v=flowCore::pData(flowCore::parameters(x));\n    return(v)\n  })\n  #annotate expr colnames\n  channels=Label[[1]]$name\n  antibodies=Label[[1]]$desc\n  antibodies=toupper(antibodies)\n  channels=toupper(channels)\n  antibodies=sapply(1:length(antibodies), function(i){\n    if(is.na(antibodies[i])|antibodies[i]==\"NA\"){return(channels[i])}else{antibodies[i]}\n  })\n  colnames(expr)=antibodies\n  #add sample_id\n  sample_id=lapply(1:length(eventN),function(i){rep(i,eventN[i])})\n  sample_id=unlist(sample_id)\n  expr=cbind(expr,\"sample_id\"=sample_id)\n  #return flowFrame\n  fFrame=flowCore::flowFrame(expr)\n  return(fFrame)\n}\n\n#' filter cluster labels\n#'\n#' A function that filter cluster labels.\n#' @param labels a vector containing labels for cell clusters\n#' @param minPlus an integer, used to specify the minmum number of \"+\" a label should contain.\n#' @param minMarker an integer, used to specify the minmum number of markers a label should contain.\n#' @param maxMarker an integer, used to specify the max number of markers a label should contain.\n#' @return returns a vector of labels that pass through the filter.\n#' @export\nfilterLabels=function(labels,minPlus,minMarker,maxMarker){\n  plus_N=sapply(labels,function(x){\n    lengths(regmatches(x, gregexpr(\"\\\\+\", x)))\n  })\n  marker_N=sapply(labels,function(x){\n    lengths(regmatches(x, gregexpr(\"\\\\|\", x)))+1\n  })\n  labels=labels[plus_N>=minPlus&marker_N<=maxMarker&marker_N>=minMarker]\n  return(labels)\n}\n\n#' find markers in a flow frame object\n#'\n#' A function that finds markers in a flow frame object.\n#' @param fcsFrame a flow frame object.\n#' @return returns a vector of markers.\n#' @details If the antibody name is available, the antibody name will be returned, otherwise the channel name will be returned.\n#' @export\nmarkerFinder=function(fcsFrame){\n  Label=flowCore::pData(flowCore::parameters(fcsFrame));\n  channels=Label$name\n  antibodies=Label$desc\n  antibodies=toupper(antibodies)\n  channels=toupper(channels)\n  antibodies=sapply(1:length(antibodies), function(i){\n    if(is.na(antibodies[i])|antibodies[i]==\"NA\"){return(channels[i])}else{antibodies[i]}\n  })\n  return(antibodies)\n}\n\n# Define meta-analysis functions----------\n\n#' perform meta-analysis\n#'\n#' A function that performs meta-analysis\n#' @param value a string to specify the column name of the dependent variable (y)\n#' @param variableOfInterst a string to specify the column name of the independent variable of interest (x1)\n#' @param otherVariables a string vector to specify the column names of independent variables included in the regression model other than the variableOfInterst.\n#' @param studyID a string to specify the column name of study ID.\n#' @param data a data frame containing the data\n#' @param CILevel a number between 0 to 1, used to specify the confidence interval to be plotted in the forrest plot.\n#' @param main a string to specify the title of the forrest plot\n#' @param ifScale a vector of two logic values, specifing if the dependent variable and the variableOfInterst should be scaled when calculating the effect size.\n#' @param cex a number specifying the amount by which plotting text and symbols should be scaled relative to the default in the forrest plot.\n#' @return returns data frame describing the effect size of variableOfInterst on value in each individule studies, as well as the over all effect size.\n#' @export\nmetaAnalysis=function(value,variableOfInterst,otherVariables,\n                      studyID,data,CILevel,main,\n                      ifScale=c(T,F),cex=1){\n  study_result=NULL\n  for(std in unique(data[,studyID])){\n    sub_data=subset(data,data[,studyID]==std)\n    sub_data=na.omit(sub_data)\n    NL=apply(sub_data[,c(value,variableOfInterst,otherVariables)],2,function(x){length(unique(x))})\n    if(!all(NL>1)){cat(std,\"is skipped. One of the variable have 0 variance.\\n\");next}\n    if(ifScale[1]){sub_data[,value]=scale(sub_data[,value])}\n    if(ifScale[2]){sub_data[,variableOfInterst]=scale(sub_data[,variableOfInterst])}\n    x=sub_data[,c(value,variableOfInterst,otherVariables)]\n    colnames(x)[1]=\"Y\"\n    LM=lm(Y~.,data=x)\n    CE=t(summary(LM)$coefficients[2,])\n    CI=confint(LM,parm=2,level=CILevel)\n    t1=cbind(\"study_id\"=std,data.frame(CE,check.names=F),\n             data.frame(CI,check.names=F),\"N\"=nrow(sub_data))\n    study_result=rbind(study_result,t1)\n  }\n  study_result=na.omit(study_result)\n  res=metafor::rma.uni(yi=study_result$Estimate, vi=(study_result$`Std. Error`)^2)\n  metafor::forest(res, slab=study_result$study_id,main=main,\n                  xlab=\"Effect Size\", mlab=\"RE Model for All Studies\",cex=cex)\n  t1=data.frame(\"Summary\",res$b[1],res$se,res$zval,res$pval,res$ci.lb,res$ci.ub,\n                sum(study_result$N))\n  names(t1)=names(study_result)\n  study_result=rbind(study_result,t1)\n  rownames(study_result)=NULL\n  return(study_result)\n}\n\n#' perform generalized linear model analysis to estimate effect size.\n#'\n#' A function that perform generalized linear model analysis to estimate effect size.\n#' @param value a string to specify the column name of the dependent variable (y)\n#' @param variableOfInterst a string to specify the column name of the independent variable of interest (x1)\n#' @param otherVariables a string vector to specify the column names of independent variables included in the regression model other than the variableOfInterst.\n#' @param parameter a string to specify what summary statistics is the dependent variale.\n#' @param studyID a string to specify the column name of study ID.\n#' @param label a string to specify the name the column that contains the cluster label or name.\n#' @param data a data frame containing the data. Usually a long form data frame returned by collectData.\n#' @param CILevel a number between 0 to 1, used to specify the confidence interval to be plotted in the forrest plot.\n#' @param ifScale a vector of two logic values, specifing if the dependent variable and the variableOfInterst should be scaled when calculating the effect size.\n#' @return returns data frame describing the overall effect size of variableOfInterst on value.  May be slightly different from the value reported from the function metaAnalysis.\n#' @details The function use the model value ~ variableOfInterst + otherVariables + studyID to estimate the effect size. Use it as a screening tool. Use metaAnalysis function to analyze an  effect size in more detail.\n#' @export\nglmAnalysis=function(value=\"value\",variableOfInterst=\"SUBJECT_AGE\",parameter,\n                     otherVariables=c(\"GENDER\"),studyID=\"study\",label=\"label\",\n                     data,CILevel=0.95,ifScale=c(T,F)){\n  result=NULL\n  for(L in unique(data[,label])){\n    sub_data=data[data$parameter_name==parameter&data[,label]==L,]\n    sub_data=na.omit(sub_data)\n    if(length(unique(sub_data[,studyID]))>1){\n      sub_data=sub_data[,c(value,variableOfInterst,otherVariables,studyID)]\n    }else{sub_data=sub_data[,c(value,variableOfInterst,otherVariables)]}\n\n    NL=apply(sub_data,2,function(x){length(unique(x))})\n    if(!all(NL>1)){cat(L,\"is skipped. One of the variable have 0 variance.\\n\");next}\n    if(ifScale[1]){sub_data[,value]=scale(sub_data[,value])}\n    if(ifScale[2]){sub_data[,variableOfInterst]=scale(sub_data[,variableOfInterst])}\n    colnames(sub_data)[1]=\"Y\"\n    LM=lm(Y~.,data=sub_data)\n    CE=t(summary(LM)$coefficients[2,])\n    CI=confint(LM,parm=2,level=CILevel)\n    t1=cbind(\"label\"=L,data.frame(CE,check.names=F),\n             data.frame(CI,check.names=F),\"N\"=nrow(sub_data))\n    result=rbind(result,t1)\n  }\n  rownames(result)=NULL\n  colnames(result)=c(\"label\",\"Effect_size\",\"SE\",\"t_value\",\"p_value\",\"lower\",\"upper\",\"N\")\n  return(result)\n}\n\n\n#' plot the result from the glmAnalysis function\n#'\n#' A function that plot the result from the glmAnalysis function.\n#' @param GA a data frame returned from the function glmAnalysis.\n#' @param size font size of texts in the plot\n#' @return NULL\n#' @export\nplotGA=function(GA,size=16){\n  GA$label=factor(GA$label,levels=GA$label)\n  p <- ggplot2::ggplot(GA, ggplot2::aes(y=GA$Effect_size,x=GA$label,ymin=lower, ymax=upper))+\n    ggplot2::geom_pointrange()+\n    ggplot2::geom_hline(yintercept = 0, linetype=2)+\n    ggplot2::coord_flip()+\n    ggplot2::xlab('label')+\n    ggplot2::ylab('Effect size')+\n    ggplot2::theme(text=ggplot2::element_text(size=size))\n  print(p)\n}\n\n\n# Define clustering functions---------\n\n#' cluster cytometry data using hierarchical clustering\n#'\n#' A function that cluster cytometry data using hierarchical clustering.\n#' @param fcsFrame a flow frame.\n#' @param excludeClusterParameters A vector specifiying the name of markers not to be used for clustering.\n#' @param minimumClusterSizePercent a number between 0 and 1, used to specify the minimum size of a cluster relative to all events.\n#' @return a list of clusters. Each cluster contains the ID of all cells that belong to the cluster.\n#' @export\nflowHC=function(fcsFrame,excludeClusterParameters,minimumClusterSizePercent=0.05){\n  antibodies=markerFinder(fcsFrame)\n  excludeClusterParameters=toupper(excludeClusterParameters)\n  excludeClusterParameters=union(excludeClusterParameters,c(\"TIME\",\"SAMPLE_ID\"))\n  w=which(!antibodies%in%excludeClusterParameters)\n  expr=flowCore::exprs(fcsFrame)\n  expr=expr[,w,drop=F]\n  D=dist(expr)\n  HC=fastcluster::hclust(D,method=\"ward.D\")\n  CL=HC.assign(HC,minimumClusterSizePercent)\n  return(CL)\n}\n\n\n#' cluster cytometry data using FlowSOM\n#'\n#' A function that cluster cytometry data using FlowSOM.\n#' @param fcsFrame a flow frame.\n#' @param excludeClusterParameters A vector specifiying the name of markers not to be used for clustering.\n#' @return a list of clusters. Each cluster contains the ID of all cells that belong to the cluster.\n#' @export\nflowSOM.MC=function(fcsFrame,excludeClusterParameters){\n  antibodies=markerFinder(fcsFrame)\n  excludeClusterParameters=toupper(excludeClusterParameters)\n  excludeClusterParameters=union(excludeClusterParameters,c(\"TIME\",\"SAMPLE_ID\"))\n  w=which(!antibodies%in%excludeClusterParameters)\n  fSOM <- FlowSOM::ReadInput(fcsFrame, transform = FALSE, scale = FALSE)\n  fSOM <- FlowSOM::BuildSOM(fSOM, colsToUse = w,\n                            xdim = 10, ydim = 10)\n  fSOM <- FlowSOM::BuildMST(fSOM)\n  meta <- FlowSOM::metaClustering_consensus(fSOM$map$codes,k=40)\n  CL <- meta[fSOM$map$mapping[, 1]]\n  CL=lapply(unique(CL),function(x){which(CL==x)})\n  return(CL)\n}\n\n\n# Define back-end functions----------\n\n#' find cutoff for a 1D distribution\n#'\n#' A function that find cutoff for a 1D distribution.\n#' @param x a vector of values.\n#' @param returnSil Logic, used to specify if the max average silhouette is returned\n#' @param useBL Logic, used to specify if outliers should be ignored\n#' @param minX a numerical value, used to specify the min value allowed for the cutoff.\n#' @return If returnSil=F, returns a single cutoff value. Otherwise, returns a list containing the cutoff value and the max average silhouette\n#' @export\nfindCutoff=function(x,returnSil=F,useBL=T,minX=0){\n  if(length(x)>2000){x=sample(x,2000)}\n  if(useBL==T){x=baselineCut(x)}\n  #valley=sapply(seq(0.01,0.99,length.out=100),function(q){quantile(x,q)})\n  valley=seq(min(x),max(x),length.out=100)\n  if(!is.null(minX)){valley=valley[valley>minX]}\n  D=dist(x)\n  sil=sapply(valley,function(v){\n    cluster=1*(x>v)+1\n    if(length(unique(cluster))<2){return(-2)}\n    ss <- cluster::silhouette(cluster,D)\n    return(mean(ss[, 3]))\n  })\n  valley=valley[which.max(sil)]\n  if(returnSil==F){return(valley)}else{return(c(\"cuoff\"=valley,\"sil\"=max(sil)))}\n}\nlabelUnifier=function(clusterLabel){\n  clusterLabel=strsplit(as.character(clusterLabel),split=\"\\\\|\")\n  clusterLabel=lapply(clusterLabel,sort)\n  clusterLabel=sapply(clusterLabel,paste,collapse=\"|\")\n  clusterLabel=toupper(clusterLabel)\n  return(clusterLabel)\n}\nlabelCombiner=function(labels){\n  label1=labels[1]\n  label2=labels[2]\n  if(nchar(label1)!=nchar(label2)){return(NA)}\n  m1=gsub(\"\\\\+|-\",\"\",label1)\n  m2=gsub(\"\\\\+|-\",\"\",label2)\n  if(m1!=m2){return(NA)}\n  label1=strsplit(label1,\"\\\\|\")[[1]]\n  label2=strsplit(label2,\"\\\\|\")[[1]]\n  s1=sapply(label1, function(x){substring(x,nchar(x))})\n  s2=sapply(label2, function(x){substring(x,nchar(x))})\n\n  if(sum(s1!=s2)!=1){return(NA)}\n  w=which(s1==s2)\n  label=label1[w]\n  label=paste(label,collapse=\"|\")\n  return(label)\n}\nHC.assign=function(HC,minimumClusterSizePercent){\n  CL=list()\n  j=0\n  NL=min(100,nrow(HC$merge))\n  for(k in 2:100){\n    t1=cutree(HC,k)\n    w=lapply(unique(t1),function(x){which(t1==x)})\n    w=w[sapply(w, length)>minimumClusterSizePercent*(nrow(HC$merge)+1)]\n\n    if(length(w)==0){break}\n    CL_new=c(CL,w)\n    if(length(unique(CL_new))==length(unique(CL))){j=j+1}else{j=0}\n    CL=unique(CL_new)\n    if(j>20){break}\n  }\n  return(CL)\n}\nbaselineCut=function(x){\n  breaks=seq(min(x),max(x),length.out=100)\n  h=hist(x,breaks,plot=F)\n  #h2=h$counts[h$counts>1]\n  baseline=max(3,mean(h$counts)/10)\n  bound=range(which(h$counts>baseline))\n  x=x[x>breaks[bound[1]]&x<breaks[bound[2]]]\n  return(x)\n}\ntrisect=function(x){\n  if(length(x)>2000){x=sample(x,2000)}\n  x=baselineCut(x)\n  D=dist(x)\n  cutoff1=findCutoff(x)\n\n  t1=findCutoff(x[x>cutoff1],useBL=F,minX=NULL)\n  cluster=.bincode(x,sort(c(-Inf,cutoff1,t1,+Inf),decreasing=F))\n  ss <- cluster::silhouette(cluster,D)\n  s1=mean(ss[, 3])\n\n  t2=findCutoff(x[x<cutoff1],useBL=F,minX=NULL)\n  cluster=.bincode(x,sort(c(-Inf,cutoff1,t2,+Inf),decreasing=F))\n  ss <- cluster::silhouette(cluster,D)\n  s2=mean(ss[, 3])\n\n  if(s2>s1){cutoff2=t2}else{cutoff2=t1}\n  return(sort(c(cutoff1,cutoff2),decreasing=T))\n}\n\n\n# Archive functions------\nlabelSummary=function(allData,minStudy=2){\n  result=NULL\n  for(label in unique(allData$label)){\n    mid_data=allData[allData$label==label,]\n    for(param in unique(allData$parameter_name)){\n      sub_data=mid_data[mid_data$parameter_name==param,]\n      if(nrow(sub_data)<1){next}\n      N_study=length(unique(sub_data$study))\n      if(N_study<minStudy){next}\n      t1=data.frame(\"label\"=label,\"parameter_name\"= param,\"number_of_study\"=N_study,\"sample_size\"=nrow(sub_data),\n                    \"studies\"=paste(unique(sub_data$study),collapse=\"|\"), row.names=NULL )\n      result=rbind(result,t1)\n    }\n  }\n  return(result)\n}\n",
    "created" : 1485645227438.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "0|27|341|0|\n17|36|78|0|\n40|51|44|2|\n99|37|179|0|\n118|34|126|4|\n139|40|142|2|\n155|43|163|4|\n195|99|267|0|\n210|45|216|4|\n225|54|227|4|\n240|52|242|8|\n246|52|249|10|\n277|53|307|0|\n319|68|339|0|\n342|24|510|1|\n362|107|392|0|\n410|49|449|0|\n421|45|428|0|\n429|37|446|54|\n464|39|510|0|\n477|45|484|0|\n485|37|490|0|\n491|31|500|0|\n501|34|508|5|\n511|29|761|0|\n525|49|555|0|\n534|43|541|2|\n542|39|547|2|\n564|39|578|0|\n594|36|605|0|\n619|81|658|0|\n671|46|683|0|\n677|53|679|6|\n691|28|721|0|\n692|45|695|2|\n696|47|700|2|\n701|46|704|2|\n710|54|712|2|\n732|58|741|0|\n733|35|735|2|\n736|37|738|2|\n750|32|760|0|\n756|54|758|2|\n762|32|873|0|\n780|44|808|0|\n827|55|851|0|\n861|28|871|0|\n874|29|920|0|\n884|82|895|0|\n905|55|918|0|\n948|36|954|0|\n955|31|972|0|\n973|49|989|0|\n990|24|998|0|\n999|20|1017|0|\n1020|19|1037|0|\n1021|42|1036|0|\n",
    "hash" : "3406539328",
    "id" : "975C28BF",
    "lastKnownWriteTime" : 1487869858,
    "last_content_update" : 1487869858108,
    "path" : "~/Box Sync/MetaCyto_related/MetaCyto/MetaCyto_Package/R/MetaCyto_functions.R",
    "project_path" : "R/MetaCyto_functions.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}